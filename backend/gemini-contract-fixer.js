// gemini-contract-fixer.js
// This utility preprocesses contracts generated by Gemini to ensure they compile properly

const fs = require('fs');
const path = require('path');
const { prepareContractForCompilation } = require('./importResolver');

/**
 * Fixes common issues in contracts generated by Gemini
 * @param {string} contractCode - The raw contract code from Gemini
 * @returns {string} - Properly formatted contract code ready for compilation
 */
function fixGeminiContract(contractCode) {
  console.log('üîç Processing Gemini-generated contract...');
  
  // Step 1: Clean up markdown artifacts if present
  let cleanedCode = cleanMarkdownArtifacts(contractCode);
  
  // Step 2: Ensure SPDX license is present
  cleanedCode = ensureLicense(cleanedCode);
  
  // Step 3: Ensure proper pragma solidity version
  cleanedCode = ensurePragma(cleanedCode);
  
  // Step 4: Add missing imports for commonly used contracts
  cleanedCode = addMissingImports(cleanedCode);
  
  // Step 5: Check for common imports and note their usage
  const usesERC721 = cleanedCode.includes('import') && cleanedCode.includes('ERC721') || 
                    (cleanedCode.includes(' is ERC721') || cleanedCode.includes(' is IERC721'));
                    
  const usesERC20 = cleanedCode.includes('import') && cleanedCode.includes('ERC20') || 
                   (cleanedCode.includes(' is ERC20') || cleanedCode.includes(' is IERC20'));
                   
  const usesStrings = cleanedCode.includes('import') && cleanedCode.includes('Strings.sol') || 
                     cleanedCode.includes('using Strings for uint');
                     
  const usesCounters = cleanedCode.includes('import') && cleanedCode.includes('Counters.sol') || 
                      cleanedCode.includes('using Counters for Counters.Counter');
  
  console.log(`Contract uses: ${usesERC721 ? 'ERC721 ' : ''}${usesERC20 ? 'ERC20 ' : ''}${usesStrings ? 'Strings ' : ''}${usesCounters ? 'Counters ' : ''}`);
  
  // Step 6: Process all imports using our importResolver
  let processedCode = prepareContractForCompilation(cleanedCode);
  
  // Step 6: Verify no imports remain (they should all be inlined now)
  if (processedCode.includes('import ')) {
    console.warn('‚ö†Ô∏è WARNING: Some imports may still be present after processing!');
    console.log('Attempting additional import resolution...');
    
    // Try one more time with a more aggressive approach
    processedCode = processedCode.replace(/import\s+[^;]+;/g, '// Import was removed');
  }
  
  console.log('‚úÖ Contract preprocessing complete!');
  return processedCode;
}

/**
 * Cleans markdown code block artifacts from Gemini output
 * @param {string} code - Raw code that might contain markdown artifacts
 * @returns {string} - Cleaned code
 */
function cleanMarkdownArtifacts(code) {
  // Remove markdown code block markers
  let cleaned = code.replace(/```solidity|```sol|```|`/g, '');
  
  // Remove potential HTML comments or special characters
  cleaned = cleaned.replace(/<!--.*?-->/g, '');
  
  return cleaned.trim();
}

/**
 * Ensures the contract has an SPDX license identifier
 * @param {string} code - Contract code
 * @returns {string} - Contract code with license
 */
function ensureLicense(code) {
  if (!code.includes('SPDX-License-Identifier')) {
    return '// SPDX-License-Identifier: MIT\n' + code;
  }
  return code;
}

/**
 * Ensures the contract has a proper pragma directive
 * @param {string} code - Contract code
 * @returns {string} - Contract code with pragma
 */
function ensurePragma(code) {
  if (!code.includes('pragma solidity')) {
    return code.includes('SPDX')
      ? code.replace(/(\/\/ SPDX.*\n)/, '$1pragma solidity ^0.8.0;\n')
      : 'pragma solidity ^0.8.0;\n' + code;
  }
  return code;
}

/**
 * Adds missing imports for commonly used contracts
 * @param {string} code - Contract code
 * @returns {string} - Contract code with imports
 */
function addMissingImports(code) {
  let updatedCode = code;
  const importMap = {
    'ERC721': '@openzeppelin/contracts/token/ERC721/ERC721.sol',
    'ERC721URIStorage': '@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol',
    'ERC20': '@openzeppelin/contracts/token/ERC20/ERC20.sol',
    'ERC1155': '@openzeppelin/contracts/token/ERC1155/ERC1155.sol',
    'Ownable': '@openzeppelin/contracts/access/Ownable.sol',
    'Counters': '@openzeppelin/contracts/utils/Counters.sol',
    'Strings': '@openzeppelin/contracts/utils/Strings.sol',
    'ReentrancyGuard': '@openzeppelin/contracts/security/ReentrancyGuard.sol',
    'Pausable': '@openzeppelin/contracts/security/Pausable.sol',
  };
  
  // Check for contract inheritance
  const contractMatch = updatedCode.match(/contract\s+\w+\s+is\s+([^{]+)/);
  if (contractMatch) {
    const inheritedContracts = contractMatch[1]
      .split(',')
      .map(c => c.trim());
    
    // Add imports for inherited contracts
    for (const contract of inheritedContracts) {
      if (importMap[contract] && !updatedCode.includes(`import "${importMap[contract]}"`)) {
        updatedCode = updatedCode.includes('pragma solidity')
          ? updatedCode.replace(/(pragma solidity[^;]+;)/, `$1\nimport "${importMap[contract]}";`)
          : `import "${importMap[contract]}";\n${updatedCode}`;
      }
    }
  }
  
  // Check for using statements
  if (updatedCode.includes('using Counters for Counters.Counter') && 
      !updatedCode.includes(`import "${importMap['Counters']}"`)) {
    updatedCode = updatedCode.includes('pragma solidity')
      ? updatedCode.replace(/(pragma solidity[^;]+;)/, `$1\nimport "${importMap['Counters']}";`)
      : `import "${importMap['Counters']}";\n${updatedCode}`;
  }
  
  if (updatedCode.includes('using Strings for') && 
      !updatedCode.includes(`import "${importMap['Strings']}"`)) {
    updatedCode = updatedCode.includes('pragma solidity')
      ? updatedCode.replace(/(pragma solidity[^;]+;)/, `$1\nimport "${importMap['Strings']}";`)
      : `import "${importMap['Strings']}";\n${updatedCode}`;
  }
  
  // Check for function signatures that might use certain contracts
  if ((updatedCode.includes('_setTokenURI') || updatedCode.includes('tokenURI(')) && 
      !updatedCode.includes(`import "${importMap['ERC721URIStorage']}"`)) {
    // If we already have ERC721 import but need URIStorage functionality
    if (updatedCode.includes(`import "${importMap['ERC721']}"`)) {
      updatedCode = updatedCode.replace(
        `import "${importMap['ERC721']}";`,
        `import "${importMap['ERC721']}";\nimport "${importMap['ERC721URIStorage']}";`
      );
    }
  }
  
  return updatedCode;
}

/**
 * Process a Gemini-generated contract file to make it compile-ready
 * @param {string} inputFilePath - Path to the input contract file
 * @param {string} [outputFilePath] - Path to save the processed contract (optional)
 * @returns {string} - The processed contract code
 */
function processGeminiContractFile(inputFilePath, outputFilePath = null) {
  try {
    console.log(`Reading contract from: ${inputFilePath}`);
    const rawCode = fs.readFileSync(inputFilePath, 'utf8');
    
    const fixedCode = fixGeminiContract(rawCode);
    
    if (outputFilePath) {
      console.log(`Saving fixed contract to: ${outputFilePath}`);
      fs.writeFileSync(outputFilePath, fixedCode);
    }
    
    return fixedCode;
  } catch (error) {
    console.error('Error processing Gemini contract:', error);
    return null;
  }
}

// Command-line interface
if (require.main === module) {
  const args = process.argv.slice(2);
  
  if (args.length < 1) {
    console.log('Usage: node gemini-contract-fixer.js <input-file> [output-file]');
    process.exit(1);
  }
  
  const inputFile = args[0];
  const outputFile = args.length > 1 ? args[1] : inputFile + '.fixed.sol';
  
  const fixedCode = processGeminiContractFile(inputFile, outputFile);
  if (fixedCode) {
    console.log('‚ú® Contract successfully processed and saved!');
  }
}

module.exports = {
  fixGeminiContract,
  processGeminiContractFile
};