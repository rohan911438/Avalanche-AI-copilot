# Frontend Integration Guide for Gemini Contract Processor

This guide explains how to integrate the Gemini Contract Processor into frontend applications to handle smart contracts generated by Gemini AI.

## Quick Start

### 1. Install Required Dependencies

```bash
npm install ethers@^6.0.0
```

### 2. Create API Client Functions

Create a utility file for API calls to the Gemini processor endpoints:

```javascript
// utils/geminiProcessorApi.js

/**
 * Fix a Gemini-generated contract without compiling
 * @param {string} contractCode - The raw contract code from Gemini
 * @returns {Promise<Object>} - { success, fixedCode, error }
 */
export async function fixGeminiContract(contractCode) {
  try {
    const response = await fetch('/api/gemini/fix', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ contractCode })
    });
    
    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.error || 'Failed to fix contract');
    }
    
    return {
      success: true,
      fixedCode: data.fixedCode
    };
    
  } catch (error) {
    console.error('Error fixing Gemini contract:', error);
    return {
      success: false,
      error: error.message || 'Failed to fix contract'
    };
  }
}

/**
 * Fix and compile a Gemini-generated contract
 * @param {string} contractCode - The raw contract code from Gemini
 * @returns {Promise<Object>} - { success, result: { abi, bytecode, fixedCode }, error }
 */
export async function compileGeminiContract(contractCode) {
  try {
    const response = await fetch('/api/gemini/compile', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ contractCode })
    });
    
    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.error || 'Failed to compile contract');
    }
    
    return {
      success: true,
      result: data.result
    };
    
  } catch (error) {
    console.error('Error compiling Gemini contract:', error);
    return {
      success: false,
      error: error.message || 'Failed to compile contract'
    };
  }
}
```

### 3. React Component Integration Example

Here's how to create a simple component that uses the Gemini processor:

```jsx
import { useState } from 'react';
import { fixGeminiContract, compileGeminiContract } from '../utils/geminiProcessorApi';

export default function GeminiContractHandler() {
  const [contractCode, setContractCode] = useState('');
  const [processedCode, setProcessedCode] = useState('');
  const [compilationResult, setCompilationResult] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  
  // Just fix the contract
  async function handleFix() {
    setIsLoading(true);
    setError(null);
    
    const result = await fixGeminiContract(contractCode);
    
    if (result.success) {
      setProcessedCode(result.fixedCode);
    } else {
      setError(result.error);
    }
    
    setIsLoading(false);
  }
  
  // Fix and compile the contract
  async function handleCompile() {
    setIsLoading(true);
    setError(null);
    setCompilationResult(null);
    
    const result = await compileGeminiContract(contractCode);
    
    if (result.success) {
      setProcessedCode(result.result.fixedCode);
      setCompilationResult({
        abi: result.result.abi,
        bytecode: result.result.bytecode
      });
    } else {
      setError(result.error);
    }
    
    setIsLoading(false);
  }
  
  return (
    <div>
      <h2>Gemini Contract Processor</h2>
      
      <textarea
        value={contractCode}
        onChange={(e) => setContractCode(e.target.value)}
        placeholder="Paste Gemini-generated contract here"
        rows={10}
        className="w-full p-2 border"
      />
      
      <div className="flex space-x-4 my-4">
        <button 
          onClick={handleFix}
          disabled={isLoading || !contractCode}
          className="px-4 py-2 bg-blue-500 text-white rounded disabled:bg-gray-300"
        >
          {isLoading ? 'Processing...' : 'Fix Contract'}
        </button>
        
        <button 
          onClick={handleCompile}
          disabled={isLoading || !contractCode}
          className="px-4 py-2 bg-green-500 text-white rounded disabled:bg-gray-300"
        >
          {isLoading ? 'Processing...' : 'Fix & Compile Contract'}
        </button>
      </div>
      
      {error && (
        <div className="bg-red-100 border border-red-400 text-red-700 p-4 mb-4 rounded">
          {error}
        </div>
      )}
      
      {processedCode && (
        <div className="mb-4">
          <h3 className="text-lg font-semibold mb-2">Processed Contract:</h3>
          <pre className="bg-gray-100 p-4 rounded overflow-auto max-h-60">
            {processedCode}
          </pre>
        </div>
      )}
      
      {compilationResult && (
        <div>
          <h3 className="text-lg font-semibold mb-2">Compilation Result:</h3>
          <p>ABI and bytecode are ready for deployment!</p>
        </div>
      )}
    </div>
  );
}
```

## Advanced Integration: Contract Deployment

To deploy the compiled contract, you can extend the integration:

```jsx
import { useState } from 'react';
import { ethers } from 'ethers';
import { compileGeminiContract } from '../utils/geminiProcessorApi';

export default function GeminiContractDeployer() {
  const [contractCode, setContractCode] = useState('');
  const [compilationResult, setCompilationResult] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [deployedAddress, setDeployedAddress] = useState(null);
  
  // Fix, compile and deploy the contract
  async function handleDeployContract() {
    setIsLoading(true);
    setError(null);
    
    try {
      // Step 1: Compile the contract
      const result = await compileGeminiContract(contractCode);
      
      if (!result.success) {
        throw new Error(result.error || 'Compilation failed');
      }
      
      const { abi, bytecode } = result.result;
      setCompilationResult({ abi, bytecode });
      
      // Step 2: Connect to wallet
      if (!window.ethereum) {
        throw new Error('No ethereum provider found. Please install MetaMask.');
      }
      
      await window.ethereum.request({ method: 'eth_requestAccounts' });
      const provider = new ethers.BrowserProvider(window.ethereum);
      const signer = await provider.getSigner();
      
      // Step 3: Create and deploy contract
      const factory = new ethers.ContractFactory(abi, bytecode, signer);
      
      // Note: You might need to handle constructor arguments here
      const contract = await factory.deploy();
      await contract.waitForDeployment();
      
      const address = await contract.getAddress();
      setDeployedAddress(address);
      
    } catch (err) {
      console.error('Error deploying contract:', err);
      setError(err.message || 'Failed to deploy contract');
    } finally {
      setIsLoading(false);
    }
  }
  
  return (
    <div>
      {/* UI Implementation */}
      <button onClick={handleDeployContract} disabled={isLoading}>
        {isLoading ? 'Deploying...' : 'Deploy Contract'}
      </button>
      
      {deployedAddress && (
        <div className="mt-4 p-4 bg-green-100 border border-green-400 rounded">
          <p>Contract successfully deployed!</p>
          <p>Address: {deployedAddress}</p>
        </div>
      )}
    </div>
  );
}
```

## Best Practices

1. **Error Handling**: Always provide clear error messages to users
2. **Loading States**: Show loading indicators during API calls
3. **Input Validation**: Validate contract code before submission
4. **Responsive Design**: Ensure the UI works well on all devices

## Common Use Cases

1. **Direct Integration with Gemini API**: Chain the Gemini API call with the contract processor
2. **Contract Review System**: Allow users to review the fixed contract before compilation
3. **Template System**: Save processed contracts as templates for future use

## Troubleshooting

- **CORS Issues**: Ensure your API endpoints are properly configured for cross-origin requests
- **Large Contracts**: Handle timeouts for large contract compilation
- **Error Parsing**: Present compilation errors in a user-friendly format

By following this guide, you can seamlessly integrate the Gemini Contract Processor into your frontend applications, providing a smooth experience for users working with AI-generated smart contracts.